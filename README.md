# goit-algo-hw-04

| Algorithm      | Small   | Medium  | Large   |
|----------------|---------|---------|---------|
| Insertion Sort | 0.02960 | 0.68674 | 2.62275 |
| Merge Sort     | 0.00947 | 0.04716 | 0.08987 |
| Timsort        | 0.00003 | 0.00014 | 0.00026 |

На основі отриманих результатів можна зробити наступні висновки:

Insertion Sort: Цей алгоритм показав найгіршу продуктивність серед трьох. Час виконання зростає досить швидко зі
збільшенням розміру вхідних даних. Це відповідає теоретичній оцінці складності алгоритму сортування вставками, яка
становить O(n²) в найгіршому випадку.

Merge Sort: Цей алгоритм показав кращу продуктивність, ніж сортування вставками. Час виконання
зростає повільніше, ніж у сортування вставками, що відповідає теоретичній оцінці складності алгоритму сортування
злиттям, яка становить O(n * log n) в найгіршому випадку.

Timsort: Цей алгоритм показав найкращу продуктивність серед трьох. Час виконання зростає найповільніше зі збільшенням
розміру вхідних даних. Це відповідає теоретичній оцінці складності Timsort, яка становить O(n * log n) в найгіршому
випадку.

Висновки:
Отримані результати підтверджують, що Timsort є найефективнішим алгоритмом сортування даних. Це пояснює, чому
Timsort є вбудованим алгоритмом сортування в Python.